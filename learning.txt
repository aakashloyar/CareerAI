{JSON.stringify(session.data?.user?.name)}
{session.data?.user?.name}


throw new Error("User not found");  
return NextResponse.json({ error: "User already exists" }, { status: 400 });

//here ist is not catched by try catch as an error while 2nd will be 



*** bcrypt not give same hashcode for same password


//why you cannot use header(localstorage) for nextjs
//next-> ssr -> in first request you cannot send header
//so next cannot get to know who is sending the request
//so you have to use cookie that go with every request


//but in react it is csr so first request it will go to server then some html
then some client then some server so local storage work here 

//session can be stored in 2 ways 
//database 
//browser
//adapter are only used when you are using database session strategy
//adapter help to add session entry in session table 


//now all the callbacks in next auth
//signin -> used to block some user
//jwt -> used to update the payload of jwt token  suck as updating user id
//session -> store important information about user to show on frontend



//3 folders
//action lib config folder which files these store

//action-> store whatever database requests
//lib -> database helpers like prismaclient password hashcode hash 
//config(static files)->give all the configurations like types and everything or also env variables

@@unique([email, sessionId]) // Ensure email + sessionId pair is unique
this line ensure no duplicate entry in table 


//serialize from cookie help in sending request in the formatted manner
// it is like prisma for req to cookie

@@index[email]
//apply index at email for fast query (implemented with B-tress or hashing)

otps  Otp[]   @relation("UserOtps")
user User @relation("UserOtps", fields: [mail], references: [email], onDelete: Cascade)
//-> now here to we need to understand about it
//otp table has => mail as foreign key that references email of table user
//user-> referecing table 
//otp-> referencing table
//referencial integrity


//flex-wrap -> more than one component in a row and window size increase
//so they will shift to next row



//horizontal and vertical scaling
//hi


// model Question {
//   id        String            @id @default(uuid())
//   question  String
//   quizId    String
//   quiz      Quiz              @relation(fields: [quizId], references: [id], onDelete: Cascade)
//   options   QuestionOption[]  // <-- relation via join table
//   correctOptionId String?     // Optional if you want to reference the correct option
//   correctOption   Option?     @relation("CorrectOption", fields: [correctOptionId], references: [id])
// }

// model Option {
//   id        String            @id @default(uuid())
//   value     String
//   questions QuestionOption[]  // <-- relation via join table
// }
// model QuestionOption {
//   question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
//   questionId String

//   option     Option   @relation(fields: [optionId], references: [id], onDelete: Cascade)
//   optionId   String

//   @@id([questionId, optionId]) // Composite primary key
// }
//this is the way to make many to many relation


//findUnique vs         findFirst
//key:must be unique    not required


//one to one

//model Question {
  id              String         @id @default(uuid())
  quizId          String  
  value           String
  quiz            Quiz           @relation("Questions",fields: [quizId], references: [id],onDelete: Cascade)         
  options         Option[]       @relation("QueOpt")
  answer          Answer?  

  @@index([quizId])
}
model Answer {
  id              String         @id  @default(uuid())
  questionId      String         @unique
  optionId        String
  question        Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
}



model Customer {
  id      Int     @id @default(autoincrement())
  name    String
  orders  Order[] // one customer has many orders
}

model Order {
  id          Int      @id @default(autoincrement())
  customerId  Int
  customer    Customer @relation(fields: [customerId], references: [id])
  orderDate   DateTime
}
//many to one relation


model Question {
  id              String         @id @default(uuid())
  quizId          String  
  value           String
  quiz            Quiz           @relation("Questions",fields: [quizId], references: [id],onDelete: Cascade)         
  options         Option[]       @relation("QueOpt")
  @@index([quizId])
}


//many to many in which you are not creating a 3rd table prisma only creating a 3rd table
model Option {
  id              String         @id @default(uuid())
  value           String
  questions       Question[]     @relation("QueOpt")  //many to many      
}

//many to many in which you are creating a external table
model Question {
  id        String           @id @default(uuid())
  quizId    String
  value     String
  quiz      Quiz             @relation("Questions", fields: [quizId], references: [id], onDelete: Cascade)

  // relation via explicit join table
  questionOptions QuestionOption[]
  
  @@index([quizId])
}

model Option {
  id        String           @id @default(uuid())
  value     String
  
  questionOptions QuestionOption[]  // relation via explicit join table
}

model QuestionOption {
  questionId String
  optionId   String
  isCorrect  Boolean  @default(false)  // mark if this option is correct for this question

  question  Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
  option    Option   @relation(fields: [optionId], references: [id], onDelete: Cascade)

  @@id([questionId, optionId])  // composite primary key to avoid duplicates
}



//e.preventdefault
//help you to prevent browser default behaviour on an action
//In React with TypeScript, component props must be passed as a single object, not as multiple parameters.